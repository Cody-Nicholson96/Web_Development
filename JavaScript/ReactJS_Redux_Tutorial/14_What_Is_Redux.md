# What Is Redux?

A problem that we will have when we try to build a single-page application using React is that we will have a lot of components that all need to communicate with each other. This can make our code very messy and hard to deal with. **Redux** is an architecture that lets us manage many components that are all on a single-page React application.

There are seven different pieces in the **Redux** architecture. This may seem overly complex at first, but no matter how big your application gets this architecture will still support it. **Redux** scales.

### Overview Of Redux

A traditional React application is broken up into components, which are just different parts of your website. These components each come with a bit of memory called *state*. The *state* is responsible for deciding how that component is going to display. For a navigation bar, the state would be the list of option text values and the list of URL links. For a video player component, the state would be the video. So we have these different components with different JavaScript objects associated with them, and each of these JavaScript objects are separate.

Say that whenever you click the "Next Video" button in a "Video Options" component, you need to change the Id of the video in a "Video Player" component and you need to tell a "Navigation Bar" component to highlight the new video you are now ;playing. Now we have three components talking to each other: "Video Options", "Video Player", and "Navigation Bar". It is hard to manage the communication between all of these components. What if we could combine all of our states into one? Instead of having a bunch of separate JavaScript objects, what if we took all of the states in the entire application and combined them into one big JavaScript object? This is exactly how **Redux** works.

You might think that combining all of our data into one object would consume a ton of memory, but it actually won't take up any more memory than it did before we merged all of our states together. When we combine all of our states together, we call this new big JavaScript object a **Store**. We still have all of our individual components, they just all have access to the **Store** that is made up of all of the *states*. But how do our individual components access the states? They do so by first using a **Provider**.

A **Provider** takes your **Store** (which is all of your application data) and it pipes them down to the individual components. For the **Provider** to pass the **Store** data to the components, the data needs to go through a **Container**. The **Container** is the glue that connects your React components with your Redux **Store**. **Containers** connect React to Redux by connecting the Redux **Store** data to the React components. The **Containers** are able to do this because they know which components require which data from the **Store**. Anytime your **Store** data changes, the components will re-render. This is the workflow for how data is handled.

Whenever a user interacts with the site by clicking something in a component, it is called an **Action**. An **Action** is usually a user generated event, but it does not have to be. You can always have **Actions** that occur when a request comes back from an API call or when finishes in the background. When an **Action** occurs, we need to determine how that event changes our application data in the **Store**. To decide how an **Action** changes our application data in our **Store**, you have to go through something called a **Reducer**. All a **Reducer** does is it takes an **Action** function and decides which part of the **Store** to change. If you wanted an **Action** to delete one of your applications movies, you would make a function called *movieReducer* that will listen for the action *deleteMovie* (Which will be called when a button is clicked) and delete a certain JavaScript object. You could use the same procedure to add a user or movie, and then just create a new JavaScript object in the **Store** using the same workflow.

The benefit of this architecture is that all of our data is saved in one place and is easy to manage. We don't have a tree architecture that we need to figure out how to pipe data up to the top, and how we would pipe data to other components. All the data is in one place.
